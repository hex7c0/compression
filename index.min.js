"use strict";

function addListeners(stream, on, listeners) {
    for (var i = 0; i < listeners.length; ++i) on.apply(stream, listeners[i]);
}

function chunkLength(chunk, encoding) {
    return chunk ? Buffer.isBuffer(chunk) ? chunk.length : Buffer.byteLength(chunk, encoding) : 0;
}

function compression(options) {
    var opts = options || Object.create(null), filter = opts.filter || shouldCompress, available = opts.available || [ "gzip", "identity" ], zlib_options = opts.zlib || {
        level: zlib.Z_BEST_SPEED,
        memLevel: zlib.Z_MAX_MEMLEVEL,
        strategy: zlib.Z_FILTERED
    }, threshold = "string" == typeof opts.threshold ? bytes(opts.threshold) : opts.threshold;
    return null === threshold && (threshold = 1024), function(req, res, next) {
        function nocompress(msg) {
            debug("no compression: %s", msg), addListeners(res, on, listeners), listeners = null;
        }
        var length, stream, ended = !1, listeners = [], write = res.write, on = res.on, end = res.end;
        return res.flush = function() {
            stream && stream.flush();
        }, res.write = function(chunk, encoding) {
            return ended === !0 ? !1 : (this._header || this._implicitHeader(), stream ? stream.write(new Buffer(chunk, encoding)) : write.call(res, chunk, encoding));
        }, res.end = function(chunk, encoding) {
            return ended === !0 ? !1 : (this._header || (this.getHeader("Content-Length") || (length = chunkLength(chunk, encoding)), 
            this._implicitHeader()), stream ? (ended = !0, chunk ? stream.end(new Buffer(chunk, encoding)) : stream.end()) : end.call(this, chunk, encoding));
        }, res.on = function(type, listener) {
            return listeners && "drain" === type ? stream ? stream.on(type, listener) : (listeners.push([ type, listener ]), 
            this) : on.call(this, type, listener);
        }, onHeaders(res, function() {
            if (!filter(req, res)) return nocompress("filtered");
            if (!shouldTransform(req, res)) return void nocompress("no transform");
            if (vary(res, "Accept-Encoding"), Number(res.getHeader("Content-Length")) < threshold || threshold > length) return void nocompress("size below threshold");
            var encoding = res.getHeader("Content-Encoding") || "identity";
            if ("identity" !== encoding) return nocompress("already encoded");
            if ("HEAD" === req.method) return nocompress("HEAD request");
            var accept = accepts(req), method = accept.encoding(available);
            if (!method || "identity" === method) return nocompress("not acceptable");
            if ("gzip" === method) stream = zlib.createGzip(zlib_options); else {
                if ("deflate" !== method) return nocompress("not acceptable");
                stream = zlib.createDeflate(zlib_options);
            }
            debug("%s compression", method), addListeners(stream, stream.on, listeners), res.setHeader("Content-Encoding", method), 
            res.removeHeader("Content-Length"), stream.on("data", function(chunk) {
                write.call(res, chunk) === !1 && stream.pause();
            }).on("end", function() {
                return end.call(res);
            }), on.call(res, "drain", function() {
                return stream.resume();
            });
        }), next();
    };
}

function shouldCompress(req, res) {
    var type = res.getHeader("Content-Type");
    return void 0 !== type && compressible(type) ? !0 : (debug("%s not compressible", type), 
    !1);
}

function shouldTransform(req, res) {
    var cacheControl = res.getHeader("Cache-Control");
    return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
}

var accepts = require("accepts"), bytes = require("bytes"), compressible = require("compressible"), debug = require("debug")("compression-zlib"), onHeaders = require("on-headers"), vary = require("vary"), zlib = require("zlib"), cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;

module.exports = compression, module.exports.filter = shouldCompress;
